# code generated by AI

import tkinter as tk
from tkinter import messagebox
import random

class TicTacToe:
    """
    A Tic-Tac-Toe game with GUI using tkinter.
    Human player (X) plays against computer (O).
    """
    
    def __init__(self, root):
        """Initialize the game with GUI components."""
        self.root = root
        self.root.title("Tic-Tac-Toe")
        
        # Game state variables
        self.board = ['' for _ in range(9)]  # Empty board with 9 positions
        self.current_player = 'X'  # Human player starts
        self.game_over = False
        
        # Colors
        self.x_color = 'red'
        self.o_color = 'blue'
        
        # Create main frame
        self.main_frame = tk.Frame(root)
        self.main_frame.pack(padx=10, pady=10)
        
        # Create game board frame
        self.board_frame = tk.Frame(self.main_frame, width=400, height=400)
        self.board_frame.pack()
        
        # Create 3x3 grid of buttons
        self.buttons = []
        for i in range(9):
            row = i // 3
            col = i % 3
            button = tk.Button(
                self.board_frame,
                text='',
                font=('Arial', 40, 'bold'),
                width=5,
                height=2,
                bg='white',
                command=lambda idx=i: self.human_move(idx)
            )
            button.grid(row=row, column=col, padx=2, pady=2, sticky='nsew')
            self.buttons.append(button)
        
        # Configure grid to be equal sized
        for i in range(3):
            self.board_frame.grid_rowconfigure(i, weight=1, minsize=133)
            self.board_frame.grid_columnconfigure(i, weight=1, minsize=133)
        
        # Create "Play Again" button
        self.play_again_button = tk.Button(
            self.main_frame,
            text='Play Again',
            font=('Arial', 14),
            command=self.reset_game,
            bg='lightgreen',
            padx=20,
            pady=5
        )
        self.play_again_button.pack(pady=10)
    
    def human_move(self, position):
        """Handle human player's move when clicking a square."""
        # Check if game is over or position is occupied
        if self.game_over or self.board[position] != '':
            return
        
        # Make the move
        self.board[position] = 'X'
        self.buttons[position].config(
            text='X', 
            fg=self.x_color,
            disabledforeground=self.x_color,
            state='disabled'
        )
        
        # Check for game end
        if self.check_winner('X'):
            self.end_game("You Won!")
            return
        elif self.is_board_full():
            self.end_game("It's a Draw!")
            return
        
        # Computer's turn
        self.current_player = 'O'
        self.root.after(500, self.computer_move)  # Delay for better UX
    
    def computer_move(self):
        """Handle computer player's move with basic AI."""
        if self.game_over:
            return
        
        # Try to win, block, or make strategic move
        position = self.get_best_move()
        
        # Make the move
        self.board[position] = 'O'
        self.buttons[position].config(
            text='O', 
            fg=self.o_color,
            disabledforeground=self.o_color,
            state='disabled'
        )
        
        # Check for game end
        if self.check_winner('O'):
            self.end_game("Computer Won!")
            return
        elif self.is_board_full():
            self.end_game("It's a Draw!")
            return
        
        # Back to human's turn
        self.current_player = 'X'
    
    def get_best_move(self):
        """
        Computer AI logic to determine the best move.
        Priority: Win > Block > Center > Corner > Side
        """
        # 1. Try to win
        move = self.find_winning_move('O')
        if move is not None:
            return move
        
        # 2. Block human from winning
        move = self.find_winning_move('X')
        if move is not None:
            return move
        
        # 3. Take center if available
        if self.board[4] == '':
            return 4
        
        # 4. Take a corner
        corners = [0, 2, 6, 8]
        available_corners = [c for c in corners if self.board[c] == '']
        if available_corners:
            return random.choice(available_corners)
        
        # 5. Take any available side
        sides = [1, 3, 5, 7]
        available_sides = [s for s in sides if self.board[s] == '']
        if available_sides:
            return random.choice(available_sides)
        
        # Fallback: take any available position
        available = [i for i in range(9) if self.board[i] == '']
        return random.choice(available)
    
    def find_winning_move(self, player):
        """Find a position where the player can win on the next move."""
        # All possible winning combinations
        winning_combinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns
            [0, 4, 8], [2, 4, 6]              # Diagonals
        ]
        
        for combo in winning_combinations:
            values = [self.board[i] for i in combo]
            # Check if player has 2 in a row and the third is empty
            if values.count(player) == 2 and values.count('') == 1:
                # Return the empty position
                for i in combo:
                    if self.board[i] == '':
                        return i
        
        return None
    
    def check_winner(self, player):
        """Check if the specified player has won."""
        winning_combinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns
            [0, 4, 8], [2, 4, 6]              # Diagonals
        ]
        
        for combo in winning_combinations:
            if all(self.board[i] == player for i in combo):
                return True
        
        return False
    
    def is_board_full(self):
        """Check if the board is completely filled."""
        return '' not in self.board
    
    def end_game(self, message):
        """End the game and show result dialog."""
        self.game_over = True
        
        # Disable all buttons
        for button in self.buttons:
            button.config(state='disabled')
        
        # Show result in a modal dialog
        messagebox.showinfo("Game Over", message)
    
    def reset_game(self):
        """Reset the game board for a new game."""
        self.board = ['' for _ in range(9)]
        self.current_player = 'X'
        self.game_over = False
        
        # Reset all buttons
        for button in self.buttons:
            button.config(text='', fg='black', state='normal')

def main():
    """Main function to run the application."""
    root = tk.Tk()
    game = TicTacToe(root)
    root.mainloop()

if __name__ == '__main__':
    main()